#include "user32.as"
#func RegisterTouchWindow "RegisterTouchWindow" int,int
#func SetProcessDPIAware "SetProcessDPIAware"
#uselib "user32.dll"
//#cfunc GetSystemMetrics "GetSystemMetrics" int
#func GetGestureInfo "GetGestureInfo" int,int
#func GetTouchInputInfo "GetTouchInputInfo" int,int,int,int
#func CloseTouchInputHandle "CloseTouchInputHandle" int
//#func ScreenToClient "ScreenToClient" int,int

SetProcessDPIAware

#define NID_MULTI_INPUT		0x40	; マルチタッチ可能フラグ
#define NID_READY		0x80	; タッチ入力可能フラグ

#define WM_GESTURE		0x0119
#define WM_TOUCH		0x0240
#define SM_DIGITIZER		94
#define SM_MAXIMUMTOUCHES	95

#enum G_SIZE=0
#enum G_FLAGS
#enum G_ID
#enum G_TARGET
#enum G_POSXY
#enum G_INST
#enum G_SEQ
#enum G_PAD
#enum G_ARGL
#enum G_ARGH
#enum G_EXT

#define F_MOVE	0x0001	;Movement has occurred. Cannot be combined with TOUCHEVENTF_DOWN.
#define F_DOWN	0x0002	;The corresponding touch point was established through a new contact. Cannot be combined with TOUCHEVENTF_MOVE or TOUCHEVENTF_UP.
#define F_UP	0x0004	;A touch point was removed.
#define F_INRANGE	0x0008	;A touch point is in range. This flag is used to enable touch hover support on compatible hardware.Applications that do not want support for hover can ignore this flag.
#define F_PRIMARY	0x0010	;Indicates that this TOUCHINPUT structure corresponds to a primary contact point. See the following text for more information on primary touch points.
#define F_NOCOALESCE	0x0020	;When received using GetTouchInputInfo, this input was not coalesced.
#define F_PALM	0x0080	;The touch event came from the user's palm.

#enum I_POSX=0
#enum I_POSY
#enum I_SOURCE
#enum I_ID
#enum I_FLAGS
#enum I_MASK
#enum I_TIME
#enum I_EXINFO
#enum I_CX
#enum I_CY

#packopt name "GDI8001KEY"
#packopt icon "GDI8001.ico"
#packopt hide 1

#define WM_LBUTTONDOWN   $0201
#define WM_LBUTTONUP     $0202
screen 0,787,247
objsize 128,24,0
pos 530,0
button gosub "Reset",*resetgdi8001
pos 660,0
button gosub "Load CMT",*popupcloadwin
title "GDI8001 Keyboard"
oncmd gosub *lbtdown,WM_LBUTTONDOWN
oncmd gosub *lbtup,WM_LBUTTONUP
oncmd gosub *OnTouch, WM_TOUCH		; メッセージ割り込み
maxinput=32
size_tinput=10
dim tinput,size_tinput*maxinput		; TOUCHINPUT構造体のバッファ
dim posxy,4
sysm=GetSystemMetrics(SM_DIGITIZER)
i=NID_MULTI_INPUT|NID_READY
if (sysm&i)!=i {
}else{
RegisterTouchWindow hwnd,0
}
color 150,120,100
keysizex=40:keysizey=40:keycnts=0:keycntst=0:keycntsx=14,13,14,11,1:keycntsxx=20,20,0,15,80,120:keycntsprev=0
repeat 53
if (cnt)=keycnts{keycntsprev=keycnts:keycnts+=keycntsx(keycntst):keycntst+=1}
keycnt0=(cnt\keycnts)-keycntsprev
keycnt1=keycntst//cnt/keycnts
boxf (keysizex*keycnt0)+keycntsxx(keycntst),(keysizey*keycnt1),(keysizex*keycnt0)+keysizex+keycntsxx(keycntst)-2,(keysizey*keycnt1)+keysizey-2
loop
repeat 20
boxf (keysizex*(cnt\4))+(keysizex*15)+18,(keysizey*((cnt/4)+1)),(keysizex*(cnt\4))+keysizex-2+(keysizex*15)+18,(keysizey*((cnt/4)+1))+keysizey-2
loop
color 90,60,40
boxf 0,keysizey*4,80-2,(keysizey*4)+keysizey-2
boxf keysizex*13,keysizey*2,(keysizex*14)+keysizex-2,(keysizey*2)+keysizey-2
boxf keysizex*13,keysizey*4,(keysizex*14)+keysizex-15-2,(keysizey*4)+keysizey-2
boxf 160,keysizey*5,(keysizex*12)-2,(keysizey*5)+keysizey-2
repeat 5
boxf 100+(80*cnt),keysizey*0,180+(80*cnt)-2,(keysizey*0)+keysizey-2
loop
color 255,255,255
repeat 5
pos 125+(80*cnt),10
mes "f･"+str(cnt+1)
loop
dim keyboardmotx,64
keyboardmotx=49,50,51,52,53,54,55,56,57,48,189,222,220,35,27,'Q','W','E','R','T','Y','U','I','O','P',192,219,17,'A','S','D','F','G','H','J','K','L',187,186,221,29,'Z','X','C','V','B','N','M',188,190,191,226,93
dim keyboardmotx2,20
keyboardmotx2=36,38,39,8,103,104,105,106,100,101,102,107,97,98,99,111,96,109,110,13
sdim keyboardmot,64,4
keyboardmot(0)="!\"#$%&'() =                          +*         <>?_"
keyboardmot(1)="1234567890-^\\  QWERTYUIOP@[ ASDFGHJKL;:] ZXCVBNM,./ "
keyboardmot(2)="  ｧｩｪｫｬｭｮｦ       ｨ                       ｯ         ･ "
keyboardmot(3)="ﾇﾌｱｳｴｵﾔﾕﾖﾜﾎﾍｰ  ﾀﾃｲｽｶﾝﾅﾆﾗｾﾞﾟ ﾁﾄｼﾊｷｸﾏﾉﾘﾚｹﾑ ﾂｻｿﾋｺﾐﾓﾈﾙﾒﾛ "
keysizex=40:keysizey=40:keycnts=0:keycntst=0:keycntsx=14,13,14,11,1:keycntsxx=20,20,0,15,80,120:keycntsprev=0
repeat 53
if (cnt)=keycnts{keycntsprev=keycnts:keycnts+=keycntsx(keycntst):keycntst+=1}
keycnt0=(cnt\keycnts)-keycntsprev
keycnt1=keycntst//cnt/keycnts
cnt2=cnt
repeat 4
pos (keysizex*keycnt0)+keycntsxx(keycntst)+(cnt/2)*20+5,(keysizey*keycnt1)+(cnt\2)*20
mes strmid(keyboardmot(cnt),cnt2,1)
loop
loop
pos (keysizex*0)+7,(keysizey*2)+11
mes "ESC"
pos (keysizex*0)+18,(keysizey*3)+11
mes "CTRL"
pos (keysizex*0)+18,(keysizey*4)+11
mes "SHIFT"
pos (keysizex*3)+3,(keysizey*5)+11
mes "GRPH"
pos (keysizex*13)+23,(keysizey*1)+11
mes "STOP"
pos (keysizex*13)+13,(keysizey*2)+11
mes "RETURN"
pos (keysizex*13)+19,(keysizey*3)+11
mes "カナ"
pos (keysizex*13)+13,(keysizey*4)+11
mes "SHIFT"
repeat 9
pos (keysizex*(cnt\3))+(keysizex*15)+18+16,(keysizey*((3-(cnt/3))+1))+10
mes str(cnt+1)
loop
pos (keysizex*(0))+(keysizex*15)+18+16,(keysizey*((4)+1))+10
mes "0"
pos (keysizex*(1))+(keysizex*15)+18+16,(keysizey*((4)+1))+10
mes ","
pos (keysizex*(2))+(keysizex*15)+18+16,(keysizey*((4)+1))+10
mes "."
pos (keysizex*(3))+(keysizex*15)+18+16,(keysizey*((1)+1))+10
mes "*"
pos (keysizex*(3))+(keysizex*15)+18+16,(keysizey*((2)+1))+10
mes "+"
pos (keysizex*(3))+(keysizex*15)+18+16,(keysizey*((3)+1))+10
mes "="
pos (keysizex*0)+(keysizex*15)+21,(keysizey*1)+3
mes "HOME"
pos (keysizex*0)+(keysizex*15)+24,(keysizey*1)+21
mes "CLR"

pos (keysizex*1)+(keysizex*15)+30,(keysizey*1)+1
mes "↓"
pos (keysizex*1)+(keysizex*15)+30,(keysizey*1)+19
mes "↑"

pos (keysizex*2)+(keysizex*15)+30,(keysizey*1)+1
mes "←"
pos (keysizex*2)+(keysizex*15)+30,(keysizey*1)+19
mes "→"


pos (keysizex*3)+(keysizex*15)+24,(keysizey*1)+3
mes "INS"
pos (keysizex*3)+(keysizex*15)+24,(keysizey*1)+21
mes "DEL"

pos (keysizex*3)+(keysizex*15)+24,(keysizey*5)+11
mes "RET"

repeat
FindWindowA 0,"GDI8001"
hGDI8001=stat
await
if hGDI8001!0{break}
loop
//mes hGDI8001


stop
*lbtdown
keysizex=40:keysizey=40:keycnts=0:keycntst=0:keycntsx=14,13,14,11,1:keycntsxx=20,20,0,15,80,120:keycntsprev=0
mx=(lparam>>(16*0))&0xFFFF
my=(lparam>>(16*1))&0xFFFF
keycode=-1
if mx>=(keysizex*0) and my>=(keysizey*4) and mx<=(keysizex*0)+keysizex and my<=(keysizey*4)+keysizey{keycode=16}
if mx>=(keysizex*13) and my>=(keysizey*4) and mx<=(keysizex*14)+keysizex and my<=(keysizey*4)+keysizey{keycode=16}
if mx>=(keysizex*13) and my>=(keysizey*2) and mx<=(keysizex*14)+keysizex and my<=(keysizey*2)+keysizey{keycode=13}
if mx>=160 and my>=keysizey*5 and mx<=(keysizex*12)-2 and my<=(keysizey*5)+keysizey-2{keycode=32}
if keycode=-1{
repeat 5
if mx>=100+(80*cnt) and my>=keysizey*0 and mx<=180+(80*cnt)-2 and my<=(keysizey*0)+keysizey-2{keycode=112+cnt}
loop
}
if keycode=-1{
repeat 20
if mx>=(keysizex*(cnt\4))+(keysizex*15)+18 and my>=(keysizey*((cnt/4)+1)) and mx<=(keysizex*(cnt\4))+keysizex-2+(keysizex*15)+18 and my<=(keysizey*((cnt/4)+1))+keysizey-2{keycode=keyboardmotx2(cnt)}
loop
}
if keycode=-1{
repeat 53
if (cnt)=keycnts{keycntsprev=keycnts:keycnts+=keycntsx(keycntst):keycntst+=1}
keycnt0=(cnt\keycnts)-keycntsprev
keycnt1=keycntst-1//cnt/keycnts
if mx>=(keysizex*keycnt0)+keycntsxx(keycntst) and my>=(keysizey*keycnt1) and mx<=(keysizex*keycnt0)+keysizex+keycntsxx(keycntst)-2 and my>=(keysizey*keycnt1)+keysizey-2{keycode=keyboardmotx(cnt)}
loop
}

if (keycode!-1){sendmsg hGDI8001,0x100,keycode,0}
return
*lbtup
keysizex=40:keysizey=40:keycnts=0:keycntst=0:keycntsx=14,13,14,11,1:keycntsxx=20,20,0,15,80,120:keycntsprev=0
mx=(lparam>>(16*0))&0xFFFF
my=(lparam>>(16*1))&0xFFFF
keycode=-1
if mx>=(keysizex*0) and my>=(keysizey*4) and mx<=(keysizex*0)+keysizex and my<=(keysizey*4)+keysizey{keycode=16}
if mx>=(keysizex*13) and my>=(keysizey*4) and mx<=(keysizex*14)+keysizex and my<=(keysizey*4)+keysizey{keycode=16}
if mx>=(keysizex*13) and my>=(keysizey*2) and mx<=(keysizex*14)+keysizex and my<=(keysizey*2)+keysizey{keycode=13}
if mx>=160 and my>=keysizey*5 and mx<=(keysizex*12)-2 and my<=(keysizey*5)+keysizey-2{keycode=32}
if keycode=-1{
repeat 5
if mx>=100+(80*cnt) and my>=keysizey*0 and mx<=180+(80*cnt)-2 and my<=(keysizey*0)+keysizey-2{keycode=112+cnt}
loop
}
if keycode=-1{
repeat 20
if mx>=(keysizex*(cnt\4))+(keysizex*15)+18 and my>=(keysizey*((cnt/4)+1)) and mx<=(keysizex*(cnt\4))+keysizex-2+(keysizex*15)+18 and my<=(keysizey*((cnt/4)+1))+keysizey-2{keycode=keyboardmotx2(cnt)}
loop
}
if keycode=-1{
repeat 53
if (cnt)=keycnts{keycntsprev=keycnts:keycnts+=keycntsx(keycntst):keycntst+=1}
keycnt0=(cnt\keycnts)-keycntsprev
keycnt1=keycntst-1//cnt/keycnts
if mx>=(keysizex*keycnt0)+keycntsxx(keycntst) and my>=(keysizey*keycnt1) and mx<=(keysizex*keycnt0)+keysizex+keycntsxx(keycntst)-2 and my>=(keysizey*keycnt1)+keysizey-2{keycode=keyboardmotx(cnt)}
loop
}

if (keycode!-1){sendmsg hGDI8001,0x101,keycode,0}
return

*OnTouch
	;	タッチ割り込み
	hinput=lparam	; HINPUTハンドル
	num=wparam	; 入力の数
	GetTouchInputInfo hinput, num, varptr(tinput), size_tinput*4
	if stat=0 : dialog "ERR:"+hinput+"("+num+")"
	i=0
	repeat num
		fl=tinput(i+I_FLAGS)
		posxy(0)=tinput(i+I_POSX)/100
		posxy(1)=tinput(i+I_POSY)/100
		ScreenToClient hwnd,varptr(posxy)
		if mx=posxy(0) and my=posxy(1){mx=0:my=0:continue}
		if fl&(F_DOWN/*|F_MOVE*/) {
			sendmsg hwnd,0x201,0,((posxy(0)&0xFFFF)<<(16*0))|((posxy(1)&0xFFFF)<<(16*1))
			//pos posxy(0)-8,posxy(1)-8:mes "●"
		}
		if fl&(F_UP){
			sendmsg hwnd,0x202,0,((posxy(0)&0xFFFF)<<(16*0))|((posxy(1)&0xFFFF)<<(16*1))
		}
		i+=size_tinput
	loop
	CloseTouchInputHandle hinput
	return

*popupcloadwin
sendmsg hGDI8001,0x100,120,0
return
*resetgdi8001
sendmsg hGDI8001,0x100,122,0
return